# Compte Rendu TP4 - Analyse Temps R√©el sous Xenomai (Pathfinder) (MI11 / AI39 - Printemps 2025)

> [Ce compte rendu a √©t√© converti de notre readme (en markdown) en PDF. Nous vous conseillons de visionner notre rapport sur ce lien](https://github.com/tigrou23/UTC-AI39-TP/tree/main/tp4)

**Nom :** [Hugo Pereira](https://github.com/tigrou23) & Maher Zizouni

**UV :** AI39

**TP :** Xenomai - TP4

**Encadrant :** Guillaume Sanahuja

---

## Question 1 : Analyse des structures et fonctions de base

### Structure `task_descriptor`

La structure `task_descriptor` permet de d√©finir tous les param√®tres n√©cessaires √† la cr√©ation d'une t√¢che temps r√©el :

```c
typedef struct task_descriptor {
  RT_TASK task;                   // Structure de t√¢che Xenomai
  void (*task_function)(void*);   // Pointeur vers la fonction ex√©cut√©e
  RTIME period;                   // P√©riodicit√© de la t√¢che
  RTIME duration;                 // Dur√©e d'ex√©cution simul√©e
  int priority;                   // Priorit√© Alchemy (1 = basse, 99 = haute)
  bool use_resource;              // Bool√©en : la t√¢che acc√®de-t-elle au bus 1553 ?
} task_descriptor;
```

### Fonction `create_and_start_rt_task`

Cette fonction encapsule le processus de cr√©ation et lancement d'une t√¢che temps r√©el avec Xenomai :

```c
int create_and_start_rt_task(struct task_descriptor* desc, RTIME first_release_point, char* name);
```

**Comportement** :

1. `rt_task_create(...)` : cr√©e la t√¢che avec une priorit√© et un nom donn√©s.
2. `rt_task_set_periodic(...)` : sp√©cifie la premi√®re activation et la p√©riodicit√©.
3. `rt_task_start(...)` : d√©marre la t√¢che avec sa fonction et ses param√®tres.

### Fonction `rt_task(void*)`

Cette fonction est celle qui est ex√©cut√©e par d√©faut pour chaque t√¢che. Elle :

* Attend un signal du s√©maphore `start_sem` avant d'ex√©cuter la boucle p√©riodique.
* Si la t√¢che utilise le bus 1553 (`use_resource == true`), elle appelle `acquire_resource()` et `release_resource()`.
* Ex√©cute un `busy_wait()` simulant la charge CPU sur une dur√©e pr√©cise.

**Avantage** : permet de d√©finir des comportements g√©n√©riques pour les t√¢ches, qui peuvent √™tre sp√©cialis√©s ensuite.

---

## Question 2 ‚Äî Utilit√© de `first_release_point` et `start_sem`

### `first_release_point`

Cette variable est un **rep√®re temporel global** permettant de synchroniser **le d√©marrage p√©riodique de toutes les t√¢ches**.

#### Dans le code :

```c
RTIME first_release_point = rt_timer_read() + 15000000;
```

#### R√¥le :

* Elle indique **le moment pr√©cis (en ns)** √† partir duquel toutes les t√¢ches vont commencer leur cycle p√©riodique.
* Assure que **toutes les t√¢ches d√©marrent simultan√©ment** (ou avec un d√©calage pr√©vu).
* Permet de :

  * tester le syst√®me dans un environnement bien contr√¥l√©,
  * produire des **chronogrammes coh√©rents**,
  * √©viter les artefacts dus √† un d√©marrage asynchrone.

---

### `start_sem`

`start_sem` est un **s√©maphore de synchronisation**, initialis√© √† 0, utilis√© pour **bloquer les t√¢ches secondaires** jusqu'√† ce que le `main` les lib√®re.

#### Dans le code :

```c
RT_SEM start_sem;
rt_sem_create(&start_sem,"start_semaphore",0,S_PRIO);
```

Chaque t√¢che secondaire appelle :

```c
rt_sem_p(&start_sem,TM_INFINITE);
```

#### R√¥le :

* Synchroniser le d√©marrage r√©el des t√¢ches **apr√®s leur cr√©ation** et la d√©finition de leur p√©riodicit√©.
* √âvite qu‚Äôune t√¢che commence **avant que toutes les autres soient pr√™tes**.

#### Lib√©ration :

```c
rt_sem_broadcast(&start_sem);
```

* Le `main` peut appeler `rt_sem_broadcast()` pour d√©bloquer toutes les t√¢ches **en m√™me temps**.

---

Ces deux m√©canismes (`first_release_point` et `start_sem`) sont donc cruciaux pour garantir une **exp√©rimentation contr√¥l√©e, reproductible et ordonn√©e** du comportement temps r√©el du syst√®me.

---

## Question 3 ‚Äî √âtapes dans `main()` pour cr√©er et synchroniser plusieurs t√¢ches

### √âtapes √† r√©aliser dans `main()`

1. **D√©finir le point de synchronisation global** :

   ```c
   RTIME first_release_point = rt_timer_read() + 15000000;
   ```

   > Donne aux t√¢ches une base de temps commune, √©vite le d√©marrage imm√©diat d√©synchronis√©.

2. **Cr√©er un s√©maphore global** :

   ```c
   rt_sem_create(&start_sem, "start_semaphore", 0, S_PRIO);
   ```

   > Permet de bloquer toutes les t√¢ches avant le d√©marrage effectif, pour assurer un d√©marrage simultan√©.

3. **Initialiser les structures des t√¢ches** (`task_descriptor`) avec :

   * `period` : p√©riode d‚Äôactivation
   * `duration` : dur√©e du `busy_wait`
   * `priority` : priorit√© Xenomai (plus petit = plus prioritaire)
   * `use_resource` : bool√©en indiquant s‚Äôil faut simuler l‚Äôusage d‚Äôune ressource critique

4. **Cr√©er et lancer chaque t√¢che avec `create_and_start_rt_task()`**

   ```c
   create_and_start_rt_task(&desc1, first_release_point, "TASK1");
   create_and_start_rt_task(&desc2, first_release_point, "TASK2");
   ...
   ```

   > Chaque t√¢che est :
   >
   > * Cr√©√©e (`rt_task_create`)
   > * Planifi√©e p√©riodiquement (`rt_task_set_periodic`)
   > * Lanc√©e (`rt_task_start`)

5. **Synchroniser avec `rt_task_sleep_until(first_release_point)`**

   ```c
   rt_task_sleep_until(first_release_point);
   ```

   > Le `main()` attend jusqu‚Äô√† ce que toutes les t√¢ches soient pr√™tes √† d√©marrer.

6. **Lib√©rer toutes les t√¢ches simultan√©ment** avec un `broadcast` :

   ```c
   rt_sem_broadcast(&start_sem);
   ```

   > Toutes les t√¢ches appelant `rt_sem_p()` se d√©bloquent et d√©marrent en m√™me temps.

7. **Terminer proprement** :

   ```c
   rt_sem_delete(&start_sem);
   return EXIT_SUCCESS;
   ```

### üõ∞Ô∏è Ajout de la t√¢che : ORDO\_BUS

```c
struct task_descriptor ORDO_BUS = {
  .task_function = rt_task,
  .period = 125000000,         // 125ms
  .duration = 2500000,         // 25ms
  .priority = 27,
  .use_resource = false
};

create_and_start_rt_task(&ORDO_BUS, first_release_point, "ORDO_BUS");
```
---

## Question 4 ‚Äî `rt_task_name`, `RT_TASK_INFO` et `threadobj_stat`

### `rt_task_name()`

Cette fonction retourne le **nom de la t√¢che temps r√©el courante**. Son impl√©mentation repose sur :

```c
static RT_TASK_INFO info;
rt_task_inquire(NULL, &info);
return info.name;
```

Elle utilise :

* `rt_task_inquire(NULL, &info)` : r√©cup√®re les infos de la t√¢che appelante.
* `info.name` : champ contenant le nom assign√© √† la t√¢che lors de sa cr√©ation avec `rt_task_create()`.

---

### Contenu de la structure `RT_TASK_INFO`

La structure `RT_TASK_INFO` est d√©finie dans `/include/alchemy/task.h`. Elle contient :

```c
typedef struct rt_task_info {
  char name[XNOBJECT_NAME_LEN];
  unsigned long period;
  RTIME exectime_period;
  RTIME exectime_total;
  long policy;
  long prio;
  pid_t pid;
  int status;
  ...
} RT_TASK_INFO;
```

üî∏ Champs utiles :

* `name` : nom de la t√¢che
* `period` : p√©riode en ns
* `prio` : priorit√© effective
* `status` : √©tat (actif, en attente, dormant‚Ä¶)
* `exectime_total` : temps total d‚Äôex√©cution (utile pour analyser la charge CPU)

---

### `threadobj_stat`

Cette structure interne est utilis√©e dans l‚Äôimpl√©mentation de Xenomai pour repr√©senter **l‚Äô√©tat global d‚Äôun thread noyau temps r√©el**.

Elle contient, selon le noyau Xenomai utilis√© :

* Infos de synchronisation (mutex, semaphores, events)
* Horodatages de r√©veil / blocage
* Liens vers les ressources associ√©es

Elle est utilis√©e pour :

* Le **debug bas-niveau**
* La **planification fine**
* Les **statistiques de performance**

On la retrouve dans les headers internes (`kernel/include/xenomai/`).


   
